package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.63

import (
	"context"
	"errors"
	"fmt"
	"graphql-tutorial/src/graph"
	"graphql-tutorial/src/graph/model"
	utilModels "graphql-tutorial/src/utils/models"
	utilModelsInterfaces "graphql-tutorial/src/utils/models/interfaces"
	"strconv"
)

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input model.CreateTodoInput) (*model.TodoResponse, error) {
	// panic(fmt.Errorf("not implemented: CreateTodo - createTodo"))
	response := model.TodoResponse{
		Error:   "",
		Success: false,
	}
	userId, err := strconv.ParseUint(input.UserID, 10, 64)

	if err != nil {
		response.Error = "Please pass a valid UserID"
		return &response, err
	}

	response = utilModels.CreateTodo(utilModelsInterfaces.CreateTodoInput{
		Started: false,
		Text:    input.Text,
		UserId:  uint(userId),
	})

	if !response.Success {
		return &response, errors.New(response.Error)
	}

	return &response, nil
}

// GetTodo is the resolver for the getTodo field.
func (r *queryResolver) GetTodo(ctx context.Context, input model.IDInput) (*model.TodoResponse, error) {
	response := model.TodoResponse{
		Error:   "",
		Success: false,
	}

	todoId, err := strconv.ParseUint(input.ID, 10, 64)
	if err != nil {
		response.Error = err.Error()
		return &response, errors.New(response.Error)
	}

	response = utilModels.FindTodoById(utilModelsInterfaces.IDInput{ID: uint(todoId)})

	if !response.Success {
		return &response, errors.New(response.Error)
	}

	return &response, nil
}

// GetTodos is the resolver for the getTodos field.
func (r *queryResolver) GetTodos(ctx context.Context, input model.IDInput) (*model.TodosResponse, error) {
	// panic(fmt.Errorf("not implemented: GetTodos - getTodos"))
	response := model.TodosResponse{}

	userId, err := strconv.ParseUint(input.ID, 10, 64)
	if err != nil {
		response.Error = err.Error()
		return &response, err
	}

	response = utilModels.FindTodosByUserId(utilModelsInterfaces.IDInput{ID: uint(userId)})

	if !response.Success {
		return &response, errors.New(response.Error)
	}

	return &response, nil
}

// User is the resolver for the user field.
func (r *todoResolver) User(ctx context.Context, obj *model.Todo) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: User - user"))
	fmt.Println("obj *model.Todo")
	fmt.Printf("%+v\n", obj) // the syntax %+v in fmt.Printf() allows you to print the field name and value of a struct

	userExists := utilModels.FindUser(utilModelsInterfaces.GetUserInput{ID: uint(obj.UserId)})

	if !userExists.Success {
		return nil, errors.New(userExists.Error)
	}

	return &model.User{
		ID:        userExists.Data.ID,
		Age:       int32(userExists.Data.Age),
		Country:   userExists.Data.Country,
		Email:     userExists.Data.Email,
		FirstName: userExists.Data.FirstName,
		LastName:  userExists.Data.LastName,
		Role:      userExists.Data.Role,
		CreatedAt: userExists.Data.CreatedAt,
		UpdatedAt: userExists.Data.UpdatedAt,
	}, nil
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

// Todo returns graph.TodoResolver implementation.
func (r *Resolver) Todo() graph.TodoResolver { return &todoResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type todoResolver struct{ *Resolver }
